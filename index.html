<html>
<head>
  <title>drape</title>
  <style>
    body {
      font-family: helvetica, arial;
      background-color: dimgray;
      margin:0px;
    }
    .fullscreen {
      position:absolute;
      top:0%;
      left:0%;
      width:100%;
      height:100%;
    }
  </style>
</head>
<body>
  <canvas id="canvas" class="fullscreen" style="width:100%; height:100%;"></canvas>
<script data-main="main" src="require.js">
/* TODO

x 3d canvas, basic webgl setup
x simple mesh triangulation of a heightmap function
x arcball viewing
 x view matrix
 x drag/touch to change angles
  x accumulate angles
x lighting and colours
o New plan
 o Height map becomes surface map with basis vectors and curvature.
 o Then take a sample grid and perturb it based on curvature and feature detection (and tool size/shape?)
 o Then generate vector field and join up into tool path.
 o Then triangulate toolpath to give renderable mesh.
* Return surface info at each 2D point, not just height
 x Rename height module
 * Return basis and curvature for cube
  * tests
 ! Rename: tangent->cutDir, cotangent to perpDir
 * Primitive evaluation performance common test
 * Return basis and curvature for sphere
  * tests
 * tests for csg union
 * Use surface info normal for mesh, dont regenerate
 * Transform basis/curvature for modifiers (rotate, translate etc)
 * Return basis/curvature for sweep
* Modify sweep to scale the profile along the path
 * Define the way the profile changes
 * Need to modify basis and curvature too
* Define an (initially uniform) sample grid
* Simple toolpath generation: simple criss/cross for now
* Triangulate from toolpath
* Generate tool path from surface info considered as a vector field
 * Property tests
* Modify mesh before toolpath generation: Coalesce samples that have low curvature
 * Property tests
* Add samples where curvature is high
 * Property tests
* Find discontinuities and increase sampling(?)
 * Property tests
* pinch to move camera in/out

*/
</script>
</body>
</html>